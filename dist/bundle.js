/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const express = __webpack_require__(/*! express */ \"express\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst cors = __webpack_require__(/*! cors */ \"cors\");\nconst dotenv = __webpack_require__(/*! dotenv */ \"dotenv\");\nconst router = __webpack_require__(/*! ./routes */ \"./routes/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst mime = __webpack_require__(/*! mime */ \"mime\");\n//setting node environment variables\nif (true) {\n  dotenv.config({\n    path: \".env\"\n  });\n} else {}\n// Set up MIME types\nmime.define({\n  \"text/css\": [\"css\"],\n  \"image/png\": [\"png\"],\n  \"image/jpeg\": [\"jpg\", \"jpeg\"],\n  \"application/pdf\": [\"pdf\"],\n  \"audio/mpeg\": [\"mp3\"],\n  \"audio/wav\": [\"wav\"],\n  \"audio/ogg\": [\"ogg\"],\n  \"audio/midi\": [\"midi\"],\n  \"audio/webm\": [\"webm\"]\n}, {\n  force: true\n});\n\n//connecting to database\nmongoose.set(\"strictQuery\", false);\nmongoose.connect(\"mongodb+srv://flraimberdiyev:gKNBsYHE1VwWB6es@test.eehlww4.mongodb.net/?retryWrites=true&w=majority\", {}).then(() => {\n  console.log(\"MongoDB ga ulanish muvaffaqqiyatli amalga oshirildi\");\n}).catch(er => {\n  console.log(\"MongoDB ga ulanishda xato ro'y berdi\", er);\n});\n\n//declaring app\nconst app = express();\n\n//configuring static files\napp.use(express.static(\"public\"));\n\n// Increase maximum payload size to 10mb\napp.use(bodyParser.json({\n  limit: \"6mb\"\n}));\napp.use(bodyParser.urlencoded({\n  limit: \"6mb\",\n  extended: true\n}));\n\n//using cors\napp.use(cors({\n  origin: [\"https://fozilbek.netlify.app\", \"http://localhost:8080\", \"http://localhost:5173\"],\n  // replace with the actual origin of your Vue.js app\n  methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n  allowedHeaders: [\"Content-Type\", \"Authorization\"]\n}));\n\n// app.use(compression)\n\napp.get(\"/\", (req, res) => {\n  res.send({\n    message: \"Assalomu alaykum!\"\n  });\n});\napp.get(\"/public/uploads/:filename\", async (req, res) => {\n  let fileName = req.params.filename;\n  fs.access(`${__dirname}/public/uploads/${fileName}`, err => {\n    if (err) {\n      console.error(err);\n      return res.status(404).send(\"Fayl topilmadi\");\n    }\n    if (req.params.filename.includes(\".png\")) {\n      res.type(\"png\");\n    } else if (req.params.filename.includes(\".jpg\")) {\n      res.type(\"jpg\");\n    } else if (req.params.filename.includes(\".jpeg\")) {\n      res.type(\"jpeg\");\n    } else {\n      return res.status(400).send({\n        message: \"Fayl ko'rsatilgan tipda emas!\"\n      });\n    }\n    return res.sendFile(`${__dirname}/public/uploads/${fileName}`);\n  });\n});\n\n//get listening audio\napp.get(\"/public/uploads/listening/:filename\", (req, res) => {\n  let fileName = req.params.filename;\n  let file = fs.access(`${__dirname}/public/uploads/listening/${fileName}`, function (err, data) {\n    if (err) {\n      console.error(err);\n      return;\n    }\n    if (req.params.filename.includes(\".mp3\")) {\n      res.type(\"mp3\");\n    } else if (req.params.filename.includes(\".wav\")) {\n      res.type(\"wav\");\n    } else if (req.params.filename.includes(\".ogg\")) {\n      res.type(\"ogg\");\n    } else if (req.params.filename.includes(\".midi \")) {\n      res.type(\"midi\");\n    } else if (req.params.filename.includes(\".webm \")) {\n      res.type(\"webm\");\n    } else {\n      return res.status(400).send({\n        message: \"Fayl ko'rsatilgan tipda emas!\"\n      });\n    }\n    // console.log(`${__dirname}/public/uploads/listening/${fileName}`)\n    return res.sendFile(`${__dirname}/public/uploads/listening/${fileName}`);\n  });\n});\n\n//initial route\napp.use(\"/api\", router);\n\n// parse application/x-www-form-urlencoded\n// app.use(bodyParser.urlencoded({ extended: true, limit : \"50mb\" }));\n// app.use(bodyParser.json({limit : \"50mb\"}))\n\n// app.use(express.json());\n// parse application/jsonapp.use(bodyParser.json());\n\n//using morgan logger\n// app.use(morgan(\"tiny\"));\n\n// listening port\napp.listen(3000, () => {\n  console.log(\"Server is listening in \", 3000);\n});\n\n//# sourceURL=webpack://todos/./index.js?");

/***/ }),

/***/ "./middleware/auth.js":
/*!****************************!*\
  !*** ./middleware/auth.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const jwt = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\nconst bcryptjs = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\nasync function checkAuth(req, res, next) {\n  const token = req.headers.authorization;\n  if (!token) {\n    return res.status(401).json({\n      message: \"Unauthorized\"\n    });\n  }\n  try {\n    const decodedToken = jwt.verify(token, process.env.JSON_SIGNATURE);\n    req.user = decodedToken;\n    next();\n  } catch (error) {\n    return res.status(401).json({\n      message: \"Unauthorized\"\n    });\n  }\n}\nmodule.exports = checkAuth;\n\n//# sourceURL=webpack://todos/./middleware/auth.js?");

/***/ }),

/***/ "./models/permissionModel.js":
/*!***********************************!*\
  !*** ./models/permissionModel.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst {\n  Schema,\n  model\n} = mongoose;\nconst permisionsSchema = new Schema({\n  name: {\n    type: String,\n    required: true\n  },\n  actions: {\n    type: [String],\n    default: []\n  }\n});\nconst Permission = model(\"permissions\", permisionsSchema);\nmodule.exports = Permission;\n\n//# sourceURL=webpack://todos/./models/permissionModel.js?");

/***/ }),

/***/ "./routes/index.js":
/*!*************************!*\
  !*** ./routes/index.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  Router\n} = __webpack_require__(/*! express */ \"express\");\nconst {\n  questionController,\n  Question\n} = __webpack_require__(/*! ./questions */ \"./routes/questions.js\");\nconst {\n  subjectController,\n  Subject\n} = __webpack_require__(/*! ./subject */ \"./routes/subject.js\");\nconst {\n  Todo\n} = __webpack_require__(/*! ./todos */ \"./routes/todos.js\");\nconst {\n  User\n} = __webpack_require__(/*! ./users */ \"./routes/users.js\");\nconst {\n  resultController\n} = __webpack_require__(/*! ./results */ \"./routes/results.js\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst router = Router();\nrouter.use((__webpack_require__(/*! body-parser */ \"body-parser\").json)());\nrouter.use(__webpack_require__(/*! cors */ \"cors\")({\n  origin: \"*\"\n}));\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  const userID = req.user.userID;\n  const user = await User.findById(userID);\n  let allTodos = await Todo.find({\n    authorId: userID\n  });\n  const todos = allTodos.filter(todo => {\n    return !todo.isMaked && new Date(new Date(todo.endDate) - new Date()).getDate() <= 3 && new Date(new Date(todo.endDate) - new Date()).getFullYear() >= 1970;\n  });\n  allTodos.forEach(async todo => {\n    if (!todo.isMaked && new Date(new Date(todo.endDate) - new Date()).getFullYear() < 1970 && !todo.isLated) {\n      todo.isLated = true;\n      return Todo.findByIdAndUpdate(todo._id, todo, {\n        new: true\n      }, (err, data) => {\n        if (err) {\n          console.log({\n            message: \"Error finding todo\"\n          });\n        }\n        if (!data) {\n          console.log({\n            message: \"Todo not found\"\n          });\n        }\n        console.log({\n          message: \"Todo succesfully updated\"\n        });\n      });\n    }\n  });\n  res.status(200).send({\n    todos,\n    user\n  });\n});\nrouter.use(\"/todos\", (__webpack_require__(/*! ./todos */ \"./routes/todos.js\").router));\nrouter.use(\"/auth\", __webpack_require__(/*! ./signInAndSignup */ \"./routes/signInAndSignup.js\"));\nrouter.use(\"/permissions\", __webpack_require__(/*! ./permissions */ \"./routes/permissions.js\"));\nrouter.use(\"/subjects\", subjectController);\nrouter.use(\"/questions\", questionController);\nrouter.use(\"/users\", (__webpack_require__(/*! ./users */ \"./routes/users.js\").router));\nrouter.use(\"/results\", resultController);\nrouter.use(\"/events\", __webpack_require__(/*! ./latePrayTimes */ \"./routes/latePrayTimes.js\"));\nrouter.use(\"/listeningQuiz\", __webpack_require__(/*! ./listeningQuiz */ \"./routes/listeningQuiz.js\"));\nmodule.exports = router;\n\n//# sourceURL=webpack://todos/./routes/index.js?");

/***/ }),

/***/ "./routes/latePrayTimes.js":
/*!*********************************!*\
  !*** ./routes/latePrayTimes.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const router = (__webpack_require__(/*! express */ \"express\").Router)();\nconst bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst multer = __webpack_require__(/*! multer */ \"multer\");\nconst upload = multer({});\nconst compression = __webpack_require__(/*! compression */ \"compression\");\n\n//define schema\nconst lateTimePraySchema = new mongoose.Schema({\n  authorId: String,\n  authorFullName: String,\n  events: [Object]\n  //   isPrayed: Boolean,\n  //   start: String,\n  //   end: String,\n  //   title: String,\n  //   content: String,\n  //   name: String,\n  //   id : Number\n});\n\n//define validation\nconst lateTimePrayValid = Joi.object({\n  authorId: Joi.string(),\n  authorFullName: Joi.string(),\n  events: Joi.array().required()\n  //   isPrayed: Joi.boolean(),\n  //   start: Joi.string().required(),\n  //   end: Joi.string().required(),\n  //   title: Joi.string().required(),\n  //   content: Joi.string().required(),\n  //   name: Joi.string().required(),\n  //   id: Joi.number().required(),\n});\n\n//define model\nconst LateTimePray = mongoose.model(\"latetimespray\", lateTimePraySchema);\n\n//get list events\nrouter.get(\"/\", async (req, res) => {\n  let events = await LateTimePray.find();\n  return res.status(200).send({\n    message: \"message\",\n    events\n  });\n});\n// router.use(compression);\n//add maked events\nrouter.post(\"/add\", async (req, res) => {\n  const {\n    error,\n    value\n  } = lateTimePrayValid.validate(req.body);\n  if (error) return res.status(400).send({\n    message: \"Bad request\"\n  });\n  let body = await LateTimePray.insertMany(value);\n\n  // const newPersonEvents = new LateTimePray(value);\n  // const savedEvents = await newPersonEvents.save();\n  return res.status(201).send({\n    message: \"Muvaffaqqiyatli qo'shildi\"\n  });\n});\n\n// router.post('/addEvents', (req, res) => {\n//   const bb = new busboy({ headers: req.headers });\n//   const fields = {};\n//   bb.on('field', (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) => {\n//     // Handle field data as stream\n//     if (!fields[fieldname]) {\n//       fields[fieldname] = [];\n//     }\n//     fields[fieldname].push(val);\n//   });\n//   bb.on('file', (fieldname, file, filename) => {\n//     // Handle file data as stream\n//   });\n//   bb.on('finish', () => {\n//     // Request stream ended\n//     res.json({ fields });x\n//   });\n//   req.pipe(bb);\n// });\n\nmodule.exports = router;\n\n//# sourceURL=webpack://todos/./routes/latePrayTimes.js?");

/***/ }),

/***/ "./routes/listeningQuiz.js":
/*!*********************************!*\
  !*** ./routes/listeningQuiz.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  Router\n} = __webpack_require__(/*! express */ \"express\");\nconst router = Router();\nconst multer = __webpack_require__(/*! multer */ \"multer\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst SALT_ROUNDS = 10;\nconst bcryptjs = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\n\n//function  check quiz\nfunction checkQuiz(textArray) {\n  for (let element of textArray) {\n    if (!element.isVisible && element.value.toLocaleLowerCase() === element.label.toLocaleLowerCase()) {\n      element[\"isCorrectFilled\"] = true;\n    }\n    element['isSelected'] = true;\n  }\n  return textArray;\n}\nfunction getStatistic(textArray) {\n  let stat = {\n    correctWordsCount: 0,\n    inCorrectWordsCount: 0,\n    notFilledWords: 0\n  };\n  for (let element of textArray) {\n    if (element.isVisible && element.value.toLocaleLowerCase() === element.label.toLocaleLowerCase()) {\n      stat.correctWordsCount++;\n    } else if (element.isSelected && !element.isVisible && element.value.toLocaleLowerCase() != element.label.toLocaleLowerCase()) {\n      stat.inCorrectWordsCount++;\n    } else if (!element.isSelected) {\n      stat.notFilledWords++;\n    }\n  }\n  return stat;\n}\nconst storage = multer.diskStorage({\n  destination: function (req, file, callback) {\n    callback(null, 'public/uploads/listening/');\n  },\n  filename: function (req, file, callback) {\n    callback(null, file.originalname);\n  }\n});\nconst upload = multer({\n  storage: storage\n});\nconst listeningQuizSchema = new mongoose.Schema({\n  name: String,\n  time: Number,\n  text: String,\n  textArray: [Object],\n  members: [Object],\n  authorId: String,\n  authorFullName: String,\n  createdDate: {\n    type: Number,\n    default: new Date().getTime()\n  },\n  isForAll: Boolean,\n  isStarted: {\n    type: Boolean,\n    default: false\n  },\n  password: String,\n  isHasPassword: Boolean,\n  authorPathImage: String,\n  audioPath: String\n});\nconst listeningQuizValSchema = Joi.object({\n  name: Joi.string().min(4).max(50).required(),\n  text: Joi.string().required(),\n  textArray: Joi.array().required(),\n  time: Joi.number().required(),\n  members: Joi.array().required(),\n  authorId: Joi.string().required(),\n  authorPathImage: Joi.string(),\n  authorFullName: Joi.string(),\n  createdDate: Joi.number(),\n  isForAll: Joi.boolean(),\n  isStarted: Joi.boolean().required(),\n  password: Joi.string(),\n  isHasPassword: Joi.boolean().required(),\n  audioPath: Joi.string().required()\n});\n\n//setting hash password subject\nlisteningQuizSchema.pre(\"save\", function (next) {\n  const quiz = this;\n  if (!quiz.isModified(\"password\")) return next();\n  bcryptjs.hash(quiz.password, SALT_ROUNDS, function (err, hashedPassword) {\n    if (err) return next(err);\n    quiz.password = hashedPassword;\n    next();\n  });\n});\nconst ListeningQuiz = mongoose.model(\"listeningquizzes\", listeningQuizSchema);\n\n//get list audio quizzes\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  let pageNumber = req.query.page || 1;\n  let pageLimit = req.query.limit || 10;\n  let isForReference = req.query.isForReference;\n  if (isForReference === true) {\n    try {\n      ListeningQuiz.find({\n        authorId: req.user.userID\n      }).skip((pageNumber - 1) * pageLimit).limit(pageLimit).exec((err, results) => {\n        if (!err) {\n          return res.status(200).send({\n            quizzes: results,\n            total: results.length\n          });\n        }\n      });\n    } catch (e) {\n      console.log(e);\n    }\n  } else {\n    ListeningQuiz.find({\n      $or: [{\n        members: {\n          $elemMatch: {\n            value: req.user.email\n          }\n        },\n        isStarted: true\n      }, {\n        authorId: req.user.userID\n      }, {\n        isForAll: true,\n        isStarted: true\n      }]\n    }).skip((pageNumber - 1) * pageLimit).limit(pageLimit).exec(function (err, results) {\n      if (!err) {\n        return res.status(200).send({\n          quizzes: results,\n          total: results.length\n        });\n      }\n    });\n  }\n});\n\n//add audio\nrouter.post(\"/add\", upload.single(\"audio\"), checkAuth, async (req, res) => {\n  const audio = req.file;\n  let body = JSON.parse(req.body.form);\n  if (audio != null || audio != undefined) {\n    body[\"audioPath\"] = process.env.HOST + audio.path;\n  }\n  const {\n    error,\n    value\n  } = listeningQuizValSchema.validate(body);\n  if (error) {\n    return res.status(400).send({\n      message: error.details[0].message\n    });\n  }\n  try {\n    let listeningquiz = await ListeningQuiz(value);\n    let newQuiz = await listeningquiz.save();\n    let all = await ListeningQuiz.find();\n    let total = await ListeningQuiz.find().countDocuments();\n    return res.status(200).send({\n      message: \"Muvaffaqqiyatli\",\n      quizs: all,\n      total\n    });\n  } catch (e) {}\n});\n\n//get by id\nrouter.get(\"/:id\", async (req, res) => {\n  let id = req.params.id;\n  if (id === \"undefined\" || id === \"null\") return res.status(400).send({\n    message: \"Fan identifikatori topilmadi...\"\n  });\n  let quiz = await ListeningQuiz.findById(id);\n  if (!quiz) {\n    return res.status(404).json({\n      message: \"Sinov topilmadi\"\n    });\n  }\n  quiz.password = undefined;\n  return res.status(200).send(quiz);\n});\n\n//edit subject route\nrouter.put(\"/update\", upload.single(\"audio\"), checkAuth, async (req, res) => {\n  let body = JSON.parse(req.body.form);\n  let audio = req.file;\n  if (audio != null || audio != undefined) {\n    body[\"audioPath\"] = process.env.HOST + audio.path;\n  }\n  const {\n    error,\n    value\n  } = listeningQuizValSchema.validate(body);\n  if (error) {\n    return res.status(400).json({\n      message: error.details[0].message\n    });\n  }\n  bcryptjs.hash(value.password, SALT_ROUNDS, (err, hashedPassword) => {\n    if (err && value.isHasPassword) return res.status(400).send({\n      message: \"Parolni saqlashda xatolik!\"\n    });\n    value.password = hashedPassword;\n    ListeningQuiz.findByIdAndUpdate(req.query.ID, value, {\n      new: true\n    }, (err, data) => {\n      if (err) {\n        return res.status(500).json({\n          message: \"Error finding quiz\"\n        });\n      }\n      if (!data) {\n        return res.status(404).json({\n          message: \"Quiz not found\"\n        });\n      }\n      return res.json({\n        message: \"Quiz succesfully updated\"\n      });\n    });\n  });\n});\n\n//update status subject\nrouter.put(\"/statusUpdate\", checkAuth, async (req, res) => {\n  const {\n    status,\n    quiz\n  } = req.body;\n  const updated = await ListeningQuiz.updateOne({\n    _id: quiz\n  }, {\n    $set: {\n      isStarted: status\n    }\n  });\n  const quizzes = await ListeningQuiz.find({\n    authorId: req.user.userID\n  });\n  return res.status(200).send({\n    message: \"Muvaffaqqiyatli\",\n    updated,\n    quizzes\n  });\n});\n\n//delete quiz\nrouter.delete(\"/delete\", async (req, res) => {\n  let id = req.query.ID;\n  try {\n    ListeningQuiz.findByIdAndRemove(id, (err, data) => {\n      if (err) {\n        return res.status(500).json({\n          message: \"Error deleting quiz\"\n        });\n      }\n      if (!data) {\n        return res.status(404).json({\n          message: \"Quiz not found\"\n        });\n      }\n      return res.json({\n        message: `Quiz deleted.`\n      });\n    });\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Internal server error\");\n  }\n});\n\n//check password quiz\nrouter.post(\"/checkPassword\", checkAuth, async (req, res) => {\n  const {\n    quizID,\n    password\n  } = req.body;\n  const existedQuiz = await ListeningQuiz.findById(quizID);\n  let comparedPassword = await bcryptjs.compare(password, existedQuiz.password);\n  if (!comparedPassword) {\n    return res.status(400).send({\n      message: \"Parol xato kiritildi...\"\n    });\n  }\n  return res.status(200).send({\n    isAllowed: true\n  });\n});\n\n//check quiz results\nrouter.post(\"/check\", checkAuth, async (req, res) => {\n  let body = req.body;\n  let result = checkQuiz(body);\n  return res.status(200).send({\n    result,\n    stat: getStatistic(body)\n  });\n});\nmodule.exports = router;\n\n//# sourceURL=webpack://todos/./routes/listeningQuiz.js?");

/***/ }),

/***/ "./routes/permissions.js":
/*!*******************************!*\
  !*** ./routes/permissions.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  Router\n} = __webpack_require__(/*! express */ \"express\");\nconst router = Router();\nconst Permission = __webpack_require__(/*! ../models/permissionModel */ \"./models/permissionModel.js\");\nconst authCheck = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\n\n//get permissions list\nrouter.get(\"/\", authCheck, async (req, res) => {\n  let permissions = await Permission.find();\n  res.status(200).json({\n    permissions\n  });\n});\nrouter.post(\"/add\", authCheck, async (req, res) => {\n  let rules = req.body;\n  if (!rules) return res.status(400).json({\n    message: \"Bad request\"\n  });\n  let newPermission = new Permission(rules);\n  let savedPermission = await newPermission.save();\n  res.status(201).json({\n    message: \"Succesfully added\"\n  });\n});\nmodule.exports = router;\n\n//# sourceURL=webpack://todos/./routes/permissions.js?");

/***/ }),

/***/ "./routes/questions.js":
/*!*****************************!*\
  !*** ./routes/questions.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const router = (__webpack_require__(/*! express */ \"express\").Router)();\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst e = __webpack_require__(/*! express */ \"express\");\nconst {\n  query\n} = __webpack_require__(/*! express */ \"express\");\nconst {\n  json\n} = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst {\n  User\n} = __webpack_require__(/*! ./users */ \"./routes/users.js\");\nconst {\n  Result\n} = __webpack_require__(/*! ./results */ \"./routes/results.js\");\nlet timeStamp = new Date().getTime();\nrouter.use(json(query));\nfunction shuffleArray(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    // Generate random number\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}\nfunction generateQuestion(list, ball) {\n  let newQuestion = {};\n  for (element of list) {\n    if (element.ball === ball && !element.isHas) {\n      newQuestion = element;\n      element.isHas = true;\n      return newQuestion;\n    }\n  }\n  return newQuestion;\n}\nfunction summBall(list) {\n  let sum = 0;\n  for (let element of list) {\n    if (element.isChecked) {\n      for (let el of element.options) {\n        if (el.isSelected && el.isTrue) {\n          sum = sum + element.ball;\n        }\n      }\n    }\n  }\n  return sum;\n}\nfunction sumCorrectAnswers(list) {\n  let sum = 0;\n  for (let key of list) {\n    key.isCorrectSelected === \"true\" ? true : false;\n    // console.log(key.isCorrectSelected, typeof key.isCorrectSelected)\n    if (key?.isCorrectSelected && key.isChecked) {\n      sum++;\n    }\n  }\n  return sum;\n}\nfunction sumIncorrectAnswers(list) {\n  let sum = 0;\n  for (let key of list) {\n    if (!key.hasOwnProperty(\"isCorrectSelected\") && key.isChecked) {\n      sum++;\n    }\n  }\n  return sum;\n}\nfunction sumNotCheckedQuestions(list) {\n  let sum = 0;\n  for (let key of list) {\n    key.isChecked === \"true\" ? true : false;\n    if (!key.isChecked) {\n      sum++;\n    }\n  }\n  return sum;\n}\nconst questionSchema = new mongoose.Schema({\n  question: String,\n  ball: Number,\n  isHas: Boolean,\n  options: [Object],\n  subjectId: String,\n  isChecked: {\n    type: Boolean,\n    default: false\n  },\n  timeStamp: {\n    type: String,\n    default: timeStamp\n  }\n});\nconst questionValSchema = Joi.object().keys({\n  options: Joi.array().items(Joi.object({\n    optionLabel: Joi.required(),\n    isTrue: Joi.boolean().required(),\n    placeholder: Joi.any(),\n    lastSelectNumber: Joi.number(),\n    isSelected: Joi.boolean()\n  })),\n  question: Joi.any().required(),\n  ball: Joi.number(),\n  isHas: Joi.boolean().required(),\n  subjectId: Joi.any().required()\n});\nconst Question = mongoose.model(\"questions\", questionSchema);\n\n//defining routes\n\n//get all questions\nrouter.post(\"/\", async (req, res) => {\n  let {\n    subjectId,\n    limit,\n    page\n  } = req.query;\n  let subject = req.body;\n  if (Object.keys(req.body).length === 0 && limit === \"0\" && page === \"0\") {\n    try {\n      let questions = await Question.find({\n        subjectId: subjectId\n      });\n      return res.status(200).send(questions);\n    } catch (e) {\n      return res.status(400).send({\n        message: e\n      });\n    }\n  }\n  if (subject?.grades) {\n    subject.grades.sort((a, b) => +a.grade - +b.grade);\n  }\n  let newQuestions = [];\n  const result = await Question.find({\n    subjectId: subjectId\n  }).skip(((page || 1) - 1) * (limit || 5)).limit(limit);\n  let questions = shuffleArray(result);\n  questions.forEach(question => shuffleArray(question.options));\n  let total = await Question.find({\n    subjectId: subjectId\n  }).countDocuments();\n  // subject.isDifferent = subject?.isDifferent === \"true\" ? true : false;\n  if (!subject.isDifferent) {\n    let questionsLimit = [];\n    let temp = [...result].reverse();\n    if (req.query?.forReference) {\n      return res.status(200).send({\n        total,\n        questions: result\n      });\n    }\n    for (let i = 0; i < subject.quizCount; i++) {\n      questionsLimit.push(questions[i]);\n    }\n    return res.status(200).send({\n      total,\n      questions: questionsLimit\n    });\n  } else {\n    if (subject?.quizCount > questions.length) {\n      return res.status(200).send(questions);\n    }\n    function generateNewMass(mass) {\n      let newMass = [];\n      let index = 0;\n      mass.forEach(element => {\n        for (let i = 0; i < +element.count; i++) {\n          newMass[index + i] = generateQuestion(questions, +element.grade);\n        }\n        index += +element.count;\n      });\n      return newMass;\n    }\n    newQuestions = generateNewMass(subject.grades);\n    return res.status(200).send({\n      questions: newQuestions\n    });\n  }\n});\n\n//add question\nrouter.post(\"/add\", checkAuth, async (req, res) => {\n  req.body.ball = req.body.ball || 0;\n  let {\n    error,\n    value\n  } = questionValSchema.validate(req.body);\n  if (error) {\n    return res.status(400).json({\n      message: error.details[0].message\n    });\n  }\n  const newQuestion = new Question(value);\n  const savedQuestion = await newQuestion.save();\n  return res.status(201).send({\n    savedQuestion,\n    message: \"Savol muvaffaqqiyatli qo'shildi\"\n  });\n});\n\n//mark tests\nrouter.post(\"/check\", checkAuth, async (req, res) => {\n  const user = await User.findById(req.user.userID);\n  let answers = req.body.questions;\n  let point = req.body.point;\n  let temp = [];\n  answers.forEach(answer => {\n    if (answer.options && answer.question) {\n      temp.push(answer);\n    }\n  });\n  if (temp.length != answers.length) {\n    // return res.status(400).send({ message: \"Ba'zi savollar yo'q bo'lganligi uchun tekshirilmadi!\" });\n    answers = temp;\n  }\n  for (const answer of answers) {\n    let largestLastSelectNumber = -Infinity;\n    let largestOptionIndex = 0;\n    for (let i = 0; i < answer?.options?.length; i++) {\n      let option = answer.options[i];\n      option.lastSelectNumber = option.lastSelectNumber || 1;\n      if (option?.lastSelectNumber > largestLastSelectNumber) {\n        largestLastSelectNumber = option.lastSelectNumber;\n        largestOptionIndex = i;\n      }\n    }\n    answer.isChecked ? answer.options[largestOptionIndex][\"isSelected\"] = true : answer.options[largestOptionIndex][\"isSelected\"] = false;\n  }\n  answers.forEach(answer => {\n    answer.options.forEach(option => {\n      if (option.isSelected && option.isTrue) {\n        return answer[\"isCorrectSelected\"] = true;\n      }\n    });\n  });\n  let isPassed = false;\n  if (summBall(answers) >= point * 60 / 100) isPassed = true;\n  if (!point) {\n    let resultTest = {\n      testerId: user.userID,\n      testerImagePath: req.user.pathImage,\n      status: sumCorrectAnswers(answers) >= req.body.subject.quizCount * 60 / 100 ? 'Passed' : \"Failed\",\n      workingDurationTime: req.body.workingDurationTime,\n      fullName: user.firstName + \" \" + user.lastName,\n      subjectId: req.body.subject?._id,\n      subjectName: req.body.subject?.name,\n      workingTime: new Date().getTime(),\n      subjectQuizTime: req.body.subject.time,\n      countCorrectAnswers: sumCorrectAnswers(answers),\n      countIncorrectAnswers: sumIncorrectAnswers(answers),\n      countNotSelectedAnswers: req.body.subject.quizCount - sumCorrectAnswers(answers) - sumIncorrectAnswers(answers),\n      correctAnswers: answers.filter(answer => answer.isCorrectSelected),\n      incorrectAnswers: answers.filter(answer => !answer.isCorrectSelected && answer.isChecked),\n      ball: summBall(answers),\n      questionsCount: req.body.subject.quizCount,\n      notSelectedAnswers: answers.filter(answer => !answer.isChecked),\n      percentageResult: 100 * sumCorrectAnswers(answers) / req.body.subject.quizCount\n    };\n    let result = await Result(resultTest);\n    let savedResult = await result.save();\n    return res.status(200).send({\n      answers,\n      correctAnswersCount: sumCorrectAnswers(answers),\n      inCorrectAnswersCount: sumIncorrectAnswers(answers),\n      notCheckedQuestionsCount: sumNotCheckedQuestions(answers)\n    });\n  } else {\n    let resultTest = {\n      subjectPoint: point,\n      subjectAuthorId: req.body.subject.authorId,\n      testerId: req.user.userID,\n      testerImagePath: user.pathImage,\n      status: isPassed ? \"Passed\" : \"Failed\",\n      workingDurationTime: req.body.workingDurationTime,\n      fullName: user.firstName + \" \" + user.lastName,\n      subjectId: req.body.subject?._id,\n      subjectName: req.body.subject?.name,\n      subjectPoint: req.body.subject.point,\n      workingTime: new Date().getTime(),\n      subjectQuizTime: req.body.subject.time,\n      countCorrectAnswers: sumCorrectAnswers(answers),\n      countIncorrectAnswers: sumIncorrectAnswers(answers),\n      countNotSelectedAnswers: req.body.subject.quizCount - sumCorrectAnswers(answers) - sumIncorrectAnswers(answers),\n      correctAnswers: answers.filter(answer => answer.isCorrectSelected),\n      incorrectAnswers: answers.filter(answer => !answer.isCorrectSelected && answer.isChecked),\n      ball: summBall(answers),\n      percentageResult: 100 * summBall(answers) / point,\n      questionsCount: req.body.subject.quizCount,\n      notSelectedAnswers: answers.filter(answer => !answer.isChecked)\n    };\n    let result = await Result(resultTest);\n    let savedResult = await result.save();\n    return res.status(200).send({\n      answers,\n      sum: summBall(answers),\n      isPassed,\n      point\n    });\n  }\n});\nrouter.get(\"/:id\", async (req, res) => {\n  let id = req.params.id;\n  if (id === \"undefined\" || id === \"null\") return res.status(400).send({\n    message: \"Savol identifikatori topilmadi!\"\n  });\n  let question = await Question.findById(id);\n  if (!question) return res.status(404).send({\n    message: \"Savol topilmadi!\"\n  });\n  return res.status(200).send({\n    question\n  });\n});\n\n//update question\nrouter.put(\"/update\", async (req, res) => {\n  let id = req.query.ID;\n  let body = req.body;\n  Question.findByIdAndUpdate(id, body, {\n    new: true\n  }, (err, data) => {\n    if (err) {\n      return res.status(500).send({\n        message: \"Savolni topishda xatolik...\"\n      });\n    }\n    if (!data) {\n      return res.status(404).send({\n        message: \"Bunaqa identifikatorli savol topilmadi...\"\n      });\n    }\n    return res.send({\n      message: \"Savol muvaffaqqiyatli yangilandi...\"\n    });\n  });\n});\n\n//delete question\nrouter.delete(\"/delete\", async (req, res) => {\n  Question.findByIdAndRemove(req.query.ID, (err, data) => {\n    if (err) {\n      return res.status(500).json({\n        message: \"Error deleting question\"\n      });\n    }\n    if (!data) {\n      return res.status(404).json({\n        message: \"Question not found\"\n      });\n    }\n    return res.json({\n      message: \"Question succesfully deleted\"\n    });\n  });\n});\nmodule.exports = {\n  questionController: router,\n  Question\n};\n\n//# sourceURL=webpack://todos/./routes/questions.js?");

/***/ }),

/***/ "./routes/results.js":
/*!***************************!*\
  !*** ./routes/results.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst router = (__webpack_require__(/*! express */ \"express\").Router)();\nconst resultSchema = new mongoose.Schema({\n  testerId: String,\n  testerImagePath: String,\n  workingTime: Date,\n  status: String,\n  workingDurationTime: Number,\n  comments: [Object],\n  fullName: String,\n  subjectId: String,\n  subjectAuthorId: String,\n  subjectName: String,\n  subjectPoint: Number,\n  subjectQuizTime: Number,\n  questionsCount: Number,\n  countCorrectAnswers: Number,\n  countIncorrectAnswers: Number,\n  correctAnswers: [Object],\n  incorrectAnswers: [Object],\n  notSelectedAnswers: [Object],\n  ball: Number,\n  percentageResult: Number,\n  countNotSelectedAnswers: Number\n});\nconst Result = mongoose.model(\"results\", resultSchema);\n\n//get list results\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  let pageNumber = req.query.page || 1;\n  let pageLimit = req.query.limit || 10;\n  let query = req.query.query;\n  let userID = req.user.userID;\n  if (query === \"me\") {\n    try {\n      Result.find({\n        testerId: userID\n      }).skip((pageNumber - 1) * pageLimit).limit(pageLimit).exec((err, results) => {\n        if (!err) {\n          Result.countDocuments({\n            testerId: userID\n          }, (err, count) => {\n            return res.status(200).send({\n              results,\n              total: count\n            });\n          });\n        }\n      });\n    } catch (e) {\n      console.log(e);\n    } finally {\n      return;\n    }\n  }\n  if (query === \"mySubjects\") {\n    try {\n      Result.find({\n        subjectAuthorId: userID\n      }).skip((pageNumber - 1) * pageLimit).limit(pageLimit).exec((err, results) => {\n        if (!err) {\n          return res.status(200).send({\n            results,\n            total: results.length\n          });\n        }\n      });\n    } catch (e) {\n      return res.send({\n        message: e.message\n      });\n    } finally {\n      return;\n    }\n  }\n  if (query === \"all\") {\n    try {\n      Result.find().skip((pageNumber - 1) * pageLimit).limit(pageLimit).exec((err, results) => {\n        if (!err) {\n          Result.countDocuments((e, count) => {\n            return res.status(200).send({\n              results,\n              total: count\n            });\n          });\n        }\n      });\n    } catch (e) {\n      return res.send({\n        message: e.message\n      });\n    } finally {\n      return;\n    }\n  }\n  return res.status(400).send({\n    message: \"Xatolik yuz berdi!\"\n  });\n});\nmodule.exports = {\n  resultController: router,\n  Result\n};\n\n//# sourceURL=webpack://todos/./routes/results.js?");

/***/ }),

/***/ "./routes/signInAndSignup.js":
/*!***********************************!*\
  !*** ./routes/signInAndSignup.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  Router\n} = __webpack_require__(/*! express */ \"express\");\nconst {\n  User,\n  userValSchema\n} = __webpack_require__(/*! ./users */ \"./routes/users.js\");\nconst bcryptjs = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\nconst router = Router();\nconst jwt = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst multer = __webpack_require__(/*! multer */ \"multer\");\nconst storage = multer.diskStorage({\n  destination: function (req, file, callback) {\n    callback(null, `public/uploads/`);\n  },\n  filename: function (req, file, callback) {\n    const filename = file.originalname.split(\" \").join(\"_\");\n    callback(null, filename);\n  }\n});\nconst upload = multer({\n  storage: storage\n});\nrouter.post(\"/login\", async (req, res) => {\n  let {\n    email,\n    password\n  } = req.body;\n  if (!email || !password) {\n    return res.status(400).json({\n      message: \"Ma'lumotlar to'liq kiritilmagan\"\n    });\n  }\n  let existedUser = await User.findOne({\n    email\n  });\n  if (!existedUser) {\n    return res.status(400).json({\n      message: \"Siz kiritgan email bo'yicha ma'lumot topilmadi\"\n    });\n  }\n  let comparedPassword = await bcryptjs.compare(password, existedUser.password);\n  if (!comparedPassword) {\n    return res.status(400).json({\n      message: \"Parol xato kiritildi\"\n    });\n  }\n  // let jsonSignature = await bcryptjs.hash(process.env.JSON_SIGNATURE, 10);\n  let payload = {\n    userID: existedUser._id,\n    email: existedUser.email\n  };\n  const token = jwt.sign(payload, process.env.JSON_SIGNATURE, {\n    expiresIn: 60 * 60 * 24\n  });\n\n  //sending user object without password property\n  existedUser.password = undefined;\n\n  //sending to client user object and token\n  res.status(200).send({\n    user: existedUser,\n    token\n  });\n});\n\n//register controller\nrouter.post(\"/register\", async (req, res) => {\n  const {\n    error,\n    value\n  } = userValSchema.validate(req.body);\n  if (error) {\n    return res.status(400).json({\n      message: error.details[0].message\n    });\n  }\n  let {\n    email,\n    phoneNumber\n  } = req.body;\n  let existedEmail = await User.findOne({\n    email\n  });\n  let existedPhoneNumber = await User.findOne({\n    phoneNumber\n  });\n  if (existedEmail) {\n    return res.status(400).json({\n      message: \"Bu email orqali allaqachon tizimdan ro'yhatdan o'tilgan\"\n    });\n  }\n  if (existedPhoneNumber) {\n    return res.status(400).json({\n      message: \"Bu raqam orqali allaqachon tizimdan ro'yhatdan o'tilgan\"\n    });\n  }\n  try {\n    let user = await User(value);\n    let savedUser = await user.save();\n    // let jsonSignature = await bcryptjs.hash(process.env.JSON_SIGNATURE, 10);\n    let payload = {\n      userID: savedUser._id,\n      email: savedUser.email\n    };\n    const token = jwt.sign(payload, process.env.JSON_SIGNATURE, {\n      expiresIn: 60 * 60 * 24\n    });\n    savedUser = await User.find().select({\n      password: 0\n    });\n    return res.status(201).send({\n      user: user,\n      token\n    });\n  } catch (e) {\n    res.errored.message = \"Server error\";\n  }\n});\n\n//get-by-email\nrouter.get(\"/user/:email\", checkAuth, async (req, res) => {\n  const email = req.params.email;\n  if (!email) {\n    return res.status(400).send({\n      message: \"Bad request\"\n    });\n  }\n  let users = await User.find();\n  users = users.filter(user => user.email.toLocaleLowerCase().includes(email.toLocaleLowerCase()));\n  return res.status(200).send(users);\n});\n\n//get-by-id\nrouter.get(\"/:id/user\", checkAuth, async (req, res) => {\n  const id = req.params.id;\n  if (!id) {\n    return res.status(400).send({\n      message: \"Bad request\"\n    });\n  }\n  let user = await User.findById(id);\n  user.password = undefined;\n  return res.status(200).send(user);\n});\n\n//get-by-id currentuser\nrouter.get(\"/user\", checkAuth, async (req, res) => {\n  const user = req.user;\n  let currentUser = await User.findById(user.userID);\n  const role = currentUser.role;\n  res.status(200).send(role || \"student\");\n});\n\n//update user\nrouter.put(\"/updateUser\", upload.single(\"file\"), checkAuth, async (req, res) => {\n  let user = JSON.parse(req.body.form);\n  user.pathImage = process.env.HOST + req.file.path;\n  const updated = await User.updateOne({\n    _id: user._id\n  }, {\n    $set: user\n  });\n  return res.status(200).send({\n    message: \"Muvaffaqqiyatli\",\n    updated,\n    user\n  });\n});\n\n//delete user\nrouter.delete(\"/delete\", async (req, res) => {\n  User.findByIdAndRemove(req.query.ID, (err, data) => {\n    if (err) {\n      return res.status(500).json({\n        message: \"Error deleting user\"\n      });\n    }\n    if (!data) {\n      return res.status(404).json({\n        message: \"User not found\"\n      });\n    }\n    return res.json({\n      message: \"User succesfully deleted\"\n    });\n  });\n});\nmodule.exports = router;\n\n//# sourceURL=webpack://todos/./routes/signInAndSignup.js?");

/***/ }),

/***/ "./routes/subject.js":
/*!***************************!*\
  !*** ./routes/subject.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const router = (__webpack_require__(/*! express */ \"express\").Router)();\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst {\n  User\n} = __webpack_require__(/*! ./users */ \"./routes/users.js\");\nconst {\n  Question\n} = __webpack_require__(/*! ./questions */ \"./routes/questions.js\");\nconst SALT_ROUNDS = 10;\nconst bcryptjs = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\nconst multer = __webpack_require__(/*! multer */ \"multer\");\n\n//defining storage for files\nconst storage = multer.diskStorage({\n  destination: function (req, file, callback) {\n    callback(null, \"public/uploads/listening/\");\n  },\n  filename: function (req, file, callback) {\n    callback(null, file.originalname);\n  }\n});\nconst upload = multer({\n  storage: storage\n});\n\n//countQuestionDefine\nasync function countQuestions(ball) {\n  let count = await Question.find({\n    ball: ball\n  }).countDocuments();\n  return count;\n}\nconst subjectSchema = new mongoose.Schema({\n  name: String,\n  time: Number,\n  quizCount: Number,\n  isDifferent: Boolean,\n  grades: [Object],\n  point: Number,\n  members: [Object],\n  authorId: String,\n  authorFullName: String,\n  createdDate: {\n    type: Number,\n    default: new Date().getTime()\n  },\n  isForAll: Boolean,\n  isStarted: {\n    type: Boolean,\n    default: false\n  },\n  password: String,\n  isHasPassword: Boolean,\n  authorPathImage: String,\n  audioPath: String\n});\nconst subjectValSchema = Joi.object({\n  name: Joi.string().min(4).max(50).required(),\n  time: Joi.number().required(),\n  quizCount: Joi.number().required(),\n  isDifferent: Joi.boolean().required(),\n  grades: Joi.array(),\n  point: Joi.number(),\n  members: Joi.array().required(),\n  authorId: Joi.string().required(),\n  authorPathImage: Joi.string(),\n  authorFullName: Joi.string(),\n  createdDate: Joi.number(),\n  isForAll: Joi.boolean(),\n  isStarted: Joi.boolean().required(),\n  password: Joi.string(),\n  isHasPassword: Joi.boolean().required(),\n  audioPath: Joi.string()\n});\n\n//setting hash password subject\nsubjectSchema.pre(\"save\", function (next) {\n  const subject = this;\n  if (!subject.isModified(\"password\")) return next();\n  bcryptjs.hash(subject.password, SALT_ROUNDS, function (err, hashedPassword) {\n    if (err) return next(err);\n    subject.password = hashedPassword;\n    next();\n  });\n});\nconst Subject = mongoose.model(\"subjects\", subjectSchema);\n\n//defining routes\n//getting all subject list\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  // 2ta asosiy shartga qarab. 1. reference uchun 2. reference uchun emas\n  //2 ta ichki holatga qarab ro'yhat beriladi. 1. admin roli uchun. 2. boshqa rollar uchun\n  let userID = req.user.userID;\n  let user = await User.findById(userID);\n  let {\n    limit,\n    page,\n    isForReference\n  } = req.query;\n  limit = Number(req.query.limit);\n  page = Number(req.query.page);\n  isForReference = Boolean(req.query.isForReference);\n  //1-asosiy shart: ro'yhat ma'lumot ustida ishlash uchun so'ralayotgan bo'lsa\n  if (req.query.isForReference === true || req.query.isForReference === 'true') {\n    if (user.role === \"admin\") {\n      Subject.find().skip((page - 1) * limit).limit(limit).exec((err, results) => {\n        if (!err) {\n          Subject.countDocuments((err, count) => {\n            return res.status(200).send({\n              subjects: results,\n              total: count\n            });\n          });\n        }\n      });\n    } else {\n      Subject.find({\n        authorId: userID\n      }).skip((page - 1) * limit).limit(limit).exec((err, results) => {\n        if (!err) {\n          Subject.countDocuments({\n            authorId: userID\n          }, (err, count) => {\n            return res.status(200).send({\n              subjects: results,\n              total: count\n            });\n          });\n        }\n      });\n    }\n  }\n  // 2-asosiy shart. ro'yhat test yechish uchun so'ralayotgan bo'lsa\n  else {\n    if (user.role === \"admin\") {\n      Subject.find().skip((page - 1) * limit).limit(limit).exec((err, results) => {\n        if (!err) {\n          Subject.countDocuments((err, count) => {\n            return res.status(200).send({\n              subjects: results,\n              total: count\n            });\n          });\n        }\n      });\n    } else {\n      Subject.find({\n        $or: [{\n          authorId: userID\n        }, {\n          isStarted: true,\n          members: {\n            $elemMatch: {\n              value: user.email\n            }\n          }\n        }]\n      }).skip((page - 1) * limit).limit(limit).exec((err, results) => {\n        if (!err) {\n          Subject.countDocuments({\n            $or: [{\n              authorId: userID\n            }, {\n              isStarted: true,\n              members: {\n                $elemMatch: {\n                  value: user.email\n                }\n              }\n            }]\n          }, (err, count) => {\n            return res.status(200).send({\n              subjects: results,\n              total: count\n            });\n          });\n        }\n      });\n    }\n  }\n});\n\n//add subject route\nrouter.post(\"/add\", upload.single(\"audio\"), checkAuth, async (req, res) => {\n  let body = JSON.parse(req.body.form);\n  let audio = req.file;\n  const {\n    error,\n    value\n  } = subjectValSchema.validate(body);\n  if (error) {\n    return res.status(400).json({\n      message: error.details[0].message\n    });\n  }\n  if (audio != null || audio != undefined) {\n    value[\"audioPath\"] = process.env.HOST + audio.path;\n  }\n  const user = await User.findById(req.user.userID);\n  value[\"authorFullName\"] = user.firstName + \" \" + user.lastName;\n  value[\"authorPathImage\"] = user.pathImage;\n  let newSubject = await Subject(value);\n  let savedSubject = await newSubject.save();\n  savedSubject.password = undefined;\n  res.status(201).send({\n    savedSubject,\n    message: \"Fan muvaffaqqiyatli qo'shildi\"\n  });\n});\n\n//get by id\nrouter.get(\"/:id\", async (req, res) => {\n  let id = req.params.id;\n  if (id === \"undefined\" || id === \"null\") return res.status(400).send({\n    message: \"Fan identifikatori topilmadi...\"\n  });\n  let subject = await Subject.findById(id);\n  if (!subject) {\n    return res.status(404).json({\n      message: \"Fan topilmadi\"\n    });\n  }\n  for (let i = 0; i < subject.grades.length; i++) {\n    const count = await Question.find({\n      ball: +subject.grades[i].grade\n    }).countDocuments();\n    subject.grades[i].countQuestions = count ? count : 0;\n  }\n  subject.password = undefined;\n  return res.status(200).send(subject);\n});\n\n//edit subject route\nrouter.put(\"/update\", checkAuth, async (req, res) => {\n  const {\n    error,\n    value\n  } = subjectValSchema.validate(req.body);\n  if (error) {\n    return res.status(400).json({\n      message: error.details[0].message\n    });\n  }\n  bcryptjs.hash(value.password, SALT_ROUNDS, (err, hashedPassword) => {\n    if (err && value.isHasPassword) return res.status(400).send({\n      message: \"Parolni saqlashda xatolik!\"\n    });\n    value.password = hashedPassword;\n    Subject.findByIdAndUpdate(req.query.ID, value, {\n      new: true\n    }, (err, data) => {\n      if (err) {\n        return res.status(500).json({\n          message: \"Error finding subject\"\n        });\n      }\n      if (!data) {\n        return res.status(404).json({\n          message: \"Subject not found\"\n        });\n      }\n      return res.json({\n        message: \"Subject succesfully updated\"\n      });\n    });\n  });\n});\n\n//update status subject\nrouter.put(\"/statusUpdate\", checkAuth, async (req, res) => {\n  const {\n    status,\n    subjectID\n  } = req.body;\n  const updated = await Subject.updateOne({\n    _id: subjectID\n  }, {\n    $set: {\n      isStarted: status\n    }\n  });\n  const subjects = await Subject.find({\n    authorId: req.user.userID\n  });\n  return res.status(200).send({\n    message: \"Muvaffaqqiyatli\",\n    updated,\n    subjects\n  });\n});\n\n//delete subject and subject questions\nrouter.delete(\"/delete\", async (req, res) => {\n  let id = req.query.ID;\n  try {\n    const result = await Question.deleteMany({\n      subjectId: id\n    });\n    Subject.findByIdAndRemove(id, (err, data) => {\n      if (err) {\n        return res.status(500).json({\n          message: \"Error deleting subject\"\n        });\n      }\n      if (!data) {\n        return res.status(404).json({\n          message: \"Subject not found\"\n        });\n      }\n      return res.json({\n        message: `Subject and ${result.deletedCount} questions deleted.`\n      });\n    });\n    // res.send(`${result.deletedCount} questions deleted.`);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Internal server error\");\n  }\n});\n\n//check password subject\nrouter.post(\"/checkPassword\", checkAuth, async (req, res) => {\n  const {\n    subject,\n    password\n  } = req.body;\n  const existedSubject = await Subject.findById(subject._id);\n  let comparedPassword = await bcryptjs.compare(password, existedSubject.password);\n  if (!comparedPassword) {\n    return res.status(400).send({\n      message: \"Parol xato kiritildi...\"\n    });\n  }\n  return res.status(200).send({\n    isAllowed: true\n  });\n});\nmodule.exports = {\n  subjectController: router,\n  Subject\n};\n\n//# sourceURL=webpack://todos/./routes/subject.js?");

/***/ }),

/***/ "./routes/todos.js":
/*!*************************!*\
  !*** ./routes/todos.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst {\n  Router\n} = __webpack_require__(/*! express */ \"express\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst router = Router();\nrouter.use(bodyParser.json());\n//todoschema\nlet todoSchema = mongoose.Schema({\n  name: String,\n  description: String,\n  date: {\n    type: Date,\n    default: Date.now\n  },\n  img: Buffer,\n  endDate: Date,\n  authorId: String,\n  isMaked: Boolean,\n  makedDate: Date,\n  isLated: Boolean\n});\nlet todoValidSchema = Joi.object({\n  name: Joi.string().required(),\n  description: Joi.string().required(),\n  endDate: Joi.date().required(),\n  authorId: Joi.string().required(),\n  isMaked: Joi.boolean().required()\n});\n\n//todo model\nlet Todo = mongoose.model(\"todos\", todoSchema);\n\n//get all data\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  let pageNumber = req.query.page || 1;\n  let pageLimit = req.query.limit || 10;\n  let allTodos = await Todo.find({\n    authorId: req.user.userID\n  }).skip((pageNumber - 1) * pageLimit).limit(pageLimit);\n  let total = await Todo.countDocuments();\n  res.status(200).send({\n    todos: allTodos,\n    total: total\n  });\n});\n\n//add todo\nrouter.post(\"/add\", checkAuth, async (req, res) => {\n  let body = req.body;\n  req.body.authorId = req.user.userID;\n  let {\n    error,\n    value\n  } = todoValidSchema.validate(req.body);\n  if (error) {\n    return res.status(400).send({\n      message: error.details[0].message\n    });\n  }\n  const todo = new Todo(body);\n  const savedTodo = await todo.save();\n  res.status(201).send({\n    message: \"Todo added succesfully\"\n  });\n});\n\n//get by id\nrouter.get(\"/:id\", async (req, res) => {\n  let id = req.params.id;\n  let todo = await Todo.findById(id);\n  if (!todo) {\n    return;\n  }\n  res.status(200).send(todo);\n});\n\n//update  by id todo\nrouter.put(\"/update\", async (req, res) => {\n  if (new Date(new Date(req.body.endDate) - new Date()).getFullYear() >= 1970) {\n    req.body.isLated = false;\n  }\n  Todo.findByIdAndUpdate(req.query.ID, req.body, {\n    new: true\n  }, (err, data) => {\n    if (err) {\n      return res.status(500).json({\n        message: \"Error finding todo\"\n      });\n    }\n    if (!data) {\n      return res.status(404).json({\n        message: \"Todo not found\"\n      });\n    }\n    return res.json({\n      message: \"Todo succesfully updated\"\n    });\n  });\n});\n\n//update status todo\nrouter.put(\"/statusUpdate\", checkAuth, async (req, res) => {\n  let data = req.body.status;\n  const ID = req.query.ID;\n  const updated = await Todo.updateOne({\n    _id: ID\n  }, {\n    $set: {\n      isMaked: true,\n      makedDate: new Date().getTime()\n    }\n  });\n  return res.status(200).send(updated);\n});\n\n//delete by id\nrouter.delete(\"/delete\", async (req, res) => {\n  Todo.findByIdAndRemove(req.query.ID, (err, data) => {\n    if (err) {\n      return res.status(500).json({\n        message: \"Error deleting todo\"\n      });\n    }\n    if (!data) {\n      return res.status(404).json({\n        message: \"Todo not found\"\n      });\n    }\n    return res.json({\n      message: \"Todo succesfully deleted\"\n    });\n  });\n});\nmodule.exports = {\n  router,\n  Todo\n};\n\n//# sourceURL=webpack://todos/./routes/todos.js?");

/***/ }),

/***/ "./routes/users.js":
/*!*************************!*\
  !*** ./routes/users.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  default: mongoose\n} = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst router = (__webpack_require__(/*! express */ \"express\").Router)();\nconst bcryptjs = __webpack_require__(/*! bcryptjs */ \"bcryptjs\");\nconst Joi = __webpack_require__(/*! joi */ \"joi\");\nconst checkAuth = __webpack_require__(/*! ../middleware/auth */ \"./middleware/auth.js\");\nconst SALT_ROUNDS = 10;\n//user schema defining\nconst userSchema = mongoose.Schema({\n  firstName: String,\n  lastName: String,\n  birdthData: String,\n  email: {\n    type: String,\n    unique: true\n  },\n  phoneNumber: {\n    type: Number,\n    unique: true\n  },\n  role: String,\n  permissions: Array,\n  password: String,\n  dataRegister: {\n    type: Number,\n    default: new Date().getTime()\n  },\n  pathImage: String\n});\n\n//user validate schema\nconst userValSchema = Joi.object({\n  firstName: Joi.string().min(5).max(30).required(),\n  lastName: Joi.string().min(5).max(30).required(),\n  birdthData: Joi.string().required(),\n  email: Joi.string().email().required(),\n  phoneNumber: Joi.number().required(),\n  role: Joi.string().required(),\n  permissions: Joi.string(),\n  password: Joi.string().pattern(new RegExp(\"^[a-zA-Z0-9]{3,30}$\")).required(),\n  dataRegister: Joi.number()\n});\n\n// userSchema.pre(\"save\", async (next) => {\n//   const salt = await bcryptjs.genSalt();\n//   this.password = await bcryptjs.hash(this.password, salt);\n//   next();\n// });\n\nuserSchema.pre('save', function (next) {\n  const user = this;\n  if (!user.isModified('password')) return next();\n  bcryptjs.hash(user.password, SALT_ROUNDS, function (err, hashedPassword) {\n    if (err) return next(err);\n    user.password = hashedPassword;\n    next();\n  });\n});\n\n//User model defining\nlet User = mongoose.model(\"users\", userSchema);\nrouter.get(\"/\", checkAuth, async (req, res) => {\n  let users = await User.find().select({\n    password: 0\n  });\n  res.send(users);\n});\nmodule.exports = {\n  User,\n  userValSchema,\n  router\n};\n\n//# sourceURL=webpack://todos/./routes/users.js?");

/***/ }),

/***/ "bcryptjs":
/*!***************************!*\
  !*** external "bcryptjs" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("bcryptjs");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("body-parser");

/***/ }),

/***/ "compression":
/*!******************************!*\
  !*** external "compression" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("compression");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("cors");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("dotenv");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "joi":
/*!**********************!*\
  !*** external "joi" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("joi");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("jsonwebtoken");

/***/ }),

/***/ "mime":
/*!***********************!*\
  !*** external "mime" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("mime");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("mongoose");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("multer");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;